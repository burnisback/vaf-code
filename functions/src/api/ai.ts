/**
 * AI API
 *
 * AI chat and project generation endpoints.
 * Uses Vertex AI (Gemini) for AI capabilities.
 */

import { onCall, HttpsError } from 'firebase-functions/v2/https';
import { Timestamp, FieldValue } from 'firebase-admin/firestore';
import { getDb, Collections, Subcollections } from '../utils/firebase';
import {
  AIChatRequest,
  AIChatResponse,
  AIGenerateProjectRequest,
  AIGenerateProjectResponse,
  ChatSession,
  ChatMessage,
  PLAN_LIMITS,
  UserPlan,
} from '../types';
import { handleError, QuotaExceededError, ValidationError } from '../utils/errors';

// Note: In production, use @google-cloud/vertexai
// For now, we'll create a mock implementation that can be swapped out

interface AIProvider {
  generateResponse(prompt: string, context?: string): Promise<{ text: string; tokensUsed: number }>;
  generateProjectFiles(prompt: string): Promise<Array<{ path: string; content: string }>>;
}

// Mock AI provider for development/testing
const mockAIProvider: AIProvider = {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async generateResponse(prompt: string, _context?: string) {
    // Simulate AI response delay
    await new Promise((resolve) => setTimeout(resolve, 500));

    const responseText = `I understand you want to: "${prompt.slice(0, 100)}..."\n\n` +
      'This is a mock AI response. In production, this would use Vertex AI (Gemini) ' +
      'to generate a helpful response about your project.';

    return {
      text: responseText,
      tokensUsed: Math.floor(prompt.length / 4) + 50,
    };
  },

  async generateProjectFiles(prompt: string) {
    // Simulate AI response delay
    await new Promise((resolve) => setTimeout(resolve, 1000));

    // Return a basic project structure
    return [
      {
        path: 'package.json',
        content: JSON.stringify(
          {
            name: 'ai-generated-project',
            version: '0.1.0',
            private: true,
            scripts: {
              dev: 'vite',
              build: 'vite build',
              preview: 'vite preview',
            },
            dependencies: {
              'react': '^18.2.0',
              'react-dom': '^18.2.0',
            },
            devDependencies: {
              '@types/react': '^18.2.0',
              '@types/react-dom': '^18.2.0',
              'typescript': '^5.0.0',
              'vite': '^5.0.0',
              '@vitejs/plugin-react': '^4.0.0',
            },
          },
          null,
          2
        ),
      },
      {
        path: 'src/App.tsx',
        content: `// Generated based on: ${prompt.slice(0, 50)}...
import React from 'react';

export default function App() {
  return (
    <div className="min-h-screen bg-gray-100 p-8">
      <h1 className="text-3xl font-bold text-gray-900">
        AI Generated Project
      </h1>
      <p className="mt-4 text-gray-600">
        This project was generated by AI based on your prompt.
      </p>
    </div>
  );
}
`,
      },
      {
        path: 'src/main.tsx',
        content: `import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
`,
      },
      {
        path: 'src/index.css',
        content: `@tailwind base;
@tailwind components;
@tailwind utilities;
`,
      },
      {
        path: 'index.html',
        content: `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AI Generated Project</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
`,
      },
    ];
  },
};

// Get AI provider (swap for real implementation in production)
function getAIProvider(): AIProvider {
  // TODO: Initialize Vertex AI in production
  // const vertexAI = new VertexAI({ project: 'vaf-system', location: 'us-central1' });
  return mockAIProvider;
}

/**
 * Check if user has AI quota remaining
 */
async function checkAIQuota(userId: string): Promise<void> {
  const db = getDb();

  // Get user plan
  const userDoc = await db.collection(Collections.USERS).doc(userId).get();
  const plan = (userDoc.data()?.plan || 'free') as UserPlan;
  const limits = PLAN_LIMITS[plan];

  // Check daily requests
  const today = new Date().toISOString().split('T')[0];
  const dailyDoc = await db
    .collection(Collections.USAGE)
    .doc(userId)
    .collection(Subcollections.DAILY)
    .doc(today)
    .get();

  const dailyRequests = dailyDoc.data()?.aiRequests || 0;

  if (dailyRequests >= limits.aiRequestsPerDay) {
    throw new QuotaExceededError('AI requests (daily limit)');
  }

  // Check monthly tokens
  const summaryDoc = await db
    .collection(Collections.USAGE)
    .doc(userId)
    .collection(Subcollections.SUMMARY)
    .doc('current')
    .get();

  const monthlyTokens = summaryDoc.data()?.aiTokens || 0;

  if (monthlyTokens >= limits.aiTokensPerMonth) {
    throw new QuotaExceededError('AI tokens (monthly limit)');
  }
}

/**
 * Record AI usage
 */
async function recordAIUsage(userId: string, tokensUsed: number): Promise<void> {
  const db = getDb();
  const today = new Date().toISOString().split('T')[0];

  const dailyRef = db
    .collection(Collections.USAGE)
    .doc(userId)
    .collection(Subcollections.DAILY)
    .doc(today);

  const summaryRef = db
    .collection(Collections.USAGE)
    .doc(userId)
    .collection(Subcollections.SUMMARY)
    .doc('current');

  // Initialize daily if needed
  const dailyDoc = await dailyRef.get();
  if (!dailyDoc.exists) {
    await dailyRef.set({
      date: today,
      projects: 0,
      deployments: 0,
      buildMinutes: 0,
      aiRequests: 0,
      aiTokens: 0,
      bandwidthMB: 0,
    });
  }

  // Update counters
  await dailyRef.update({
    aiRequests: FieldValue.increment(1),
    aiTokens: FieldValue.increment(tokensUsed),
  });

  await summaryRef.update({
    aiTokens: FieldValue.increment(tokensUsed),
  });
}

/**
 * AI Chat endpoint
 */
export const aiChat = onCall<AIChatRequest, Promise<AIChatResponse>>(
  { cors: true, timeoutSeconds: 60 },
  async (request) => {
    try {
      if (!request.auth) {
        throw new HttpsError('unauthenticated', 'Authentication required');
      }

      const userId = request.auth.uid;
      const { projectId, sessionId, message } = request.data;

      if (!message || message.trim().length === 0) {
        throw new ValidationError('Message is required');
      }

      // Check quota
      await checkAIQuota(userId);

      const db = getDb();
      const now = Timestamp.now();
      const ai = getAIProvider();

      // Get or create session
      let currentSessionId = sessionId;
      const sessionsRef = db
        .collection(Collections.USERS)
        .doc(userId)
        .collection(Subcollections.CHAT_SESSIONS);

      if (!currentSessionId) {
        // Create new session
        const sessionRef = sessionsRef.doc();
        const session: ChatSession = {
          id: sessionRef.id,
          projectId: projectId || '',
          createdAt: now,
          updatedAt: now,
          messageCount: 0,
        };
        await sessionRef.set(session);
        currentSessionId = sessionRef.id;
      }

      const sessionRef = sessionsRef.doc(currentSessionId);
      const messagesRef = sessionRef.collection(Subcollections.MESSAGES);

      // Store user message
      const userMessageRef = messagesRef.doc();
      const userMessage: ChatMessage = {
        id: userMessageRef.id,
        role: 'user',
        content: message,
        createdAt: now,
      };
      await userMessageRef.set(userMessage);

      // Load context if projectId provided
      let context = '';
      if (projectId) {
        const projectDoc = await db.collection(Collections.PROJECTS).doc(projectId).get();
        if (projectDoc.exists) {
          const project = projectDoc.data();
          context = `Project: ${project?.name}\nFramework: ${project?.framework}\nDescription: ${project?.description}`;
        }
      }

      // Generate AI response
      const aiResult = await ai.generateResponse(message, context);

      // Store assistant message
      const assistantMessageRef = messagesRef.doc();
      const assistantMessage: ChatMessage = {
        id: assistantMessageRef.id,
        role: 'assistant',
        content: aiResult.text,
        createdAt: Timestamp.now(),
        tokensUsed: aiResult.tokensUsed,
      };
      await assistantMessageRef.set(assistantMessage);

      // Update session
      await sessionRef.update({
        updatedAt: Timestamp.now(),
        messageCount: FieldValue.increment(2),
      });

      // Record usage
      await recordAIUsage(userId, aiResult.tokensUsed);

      return {
        response: aiResult.text,
        sessionId: currentSessionId,
        tokensUsed: aiResult.tokensUsed,
      };
    } catch (error) {
      throw handleError(error);
    }
  }
);

/**
 * AI Project Generation endpoint
 */
export const aiGenerateProject = onCall<AIGenerateProjectRequest, Promise<AIGenerateProjectResponse>>(
  { cors: true, timeoutSeconds: 120 },
  async (request) => {
    try {
      if (!request.auth) {
        throw new HttpsError('unauthenticated', 'Authentication required');
      }

      const userId = request.auth.uid;
      const { prompt, framework = 'React' } = request.data;

      if (!prompt || prompt.trim().length === 0) {
        throw new ValidationError('Prompt is required');
      }

      // Check quota
      await checkAIQuota(userId);

      const db = getDb();
      const now = Timestamp.now();
      const ai = getAIProvider();

      // Generate project files
      const files = await ai.generateProjectFiles(`${prompt}\nFramework: ${framework}`);

      // Create project
      const projectRef = db.collection(Collections.PROJECTS).doc();
      const project = {
        id: projectRef.id,
        userId,
        name: `AI Project - ${new Date().toLocaleDateString()}`,
        description: prompt.slice(0, 200),
        status: 'draft',
        framework,
        createdAt: now,
        updatedAt: now,
      };

      await projectRef.set(project);

      // Store files in project subcollection
      const filesRef = projectRef.collection(Subcollections.FILES);
      for (const file of files) {
        const fileRef = filesRef.doc();
        await fileRef.set({
          id: fileRef.id,
          path: file.path,
          content: file.content,
          type: 'file',
          updatedAt: now,
        });
      }

      // Record usage (estimate tokens based on generated content)
      const totalChars = files.reduce((sum, f) => sum + f.content.length, 0);
      const estimatedTokens = Math.floor(totalChars / 4) + 500;
      await recordAIUsage(userId, estimatedTokens);

      // Update project count
      const summaryRef = db
        .collection(Collections.USAGE)
        .doc(userId)
        .collection(Subcollections.SUMMARY)
        .doc('current');

      await summaryRef.update({
        totalProjects: FieldValue.increment(1),
      });

      return {
        projectId: projectRef.id,
        files,
      };
    } catch (error) {
      throw handleError(error);
    }
  }
);
